'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-backend/docs/mq/mqtt/mosquitto/','title':"mosquitto",'content':"mosquitto 物联网（Internet of Things，IoT）最近曝光率越来越高。虽然 HTTP 是网页的事实标准，不过机器之间（Machine-to-Machine，M2M）的大规模沟通需要不同的模式：之前的请求 / 回答（Request/Response）模式不再合适，取而代之的是发布 / 订阅（Publish/Subscribe）模式。这就是轻量级、可扩展的 MQTT（Message Queuing Telemetry Transport）可以施展拳脚的舞台。\nMQTT 是基于二进制消息的发布 / 订阅编程模式的消息协议，最早由 IBM 提出的，如今已经成为 OASIS 规范。由于规范很简单，非常适合需要低功耗和网络带宽有限的 IoT 场景，比如：\n 遥感数据 汽车 智能家居 智慧城市 医疗医护  安装 MacOS brew install mosquitto\n参考：https://mosquitto.org/download/\n"});index.add({'id':1,'href':'/study-backend/docs/auth/sso/cas/','title':"CAS",'content':"CAS 简介 集中式认证服务（英语：Central Authentication Service，缩写 **CAS **）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需提供一次凭证（如用户名和密码）。它还允许 web 应用程序在没有获得用户的安全凭据（如密码）的情况下对用户进行身份验证。\u0026ldquo;CAS\u0026rdquo; 也指实现了该协议的软件包。\nCAS 是由耶鲁大学 的 Shawn Bayern 创始的，后来由耶鲁大学的 Drew Mazurek 维护。CAS1.0 实现了单点登录。 CAS2.0 引入了多级代理认证（Multi-tier proxy authentication）。CAS 其他几个版本已经有了新的功能。\n2004 年 12 月，CAS 成为 Jasig（英语：Jasig）的一个项目，2008 年该组织负责 CAS 的维护和发展。CAS 原名 \u0026ldquo;耶鲁大学 CAS\u0026rdquo;，现在则被称为 \u0026ldquo;Jasig CAS\u0026rdquo;。\n原理 Cas Server  sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--cs: /validate 验证合法性 alt 正常登录 cs--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 cs--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, cs: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 cs-c: 返回错误提示页面 end end end Session Server + Cas Server sequenceDiagram participant c as Client (The browser) participant ws as Web Server participant cs as CAS Server participant ss as Session Server c-ws: 访问网站地址 Note over ws: 尝试从 cookie 获取 pToken 和 sToken alt pToken 和 sToken 同时存在 ws--ss: /validate 验证合法性 alt 正常登录 ss--ws: 返回用户信息 ws-c: 返回用户请求内容 else 不正常 ss--ws: 返回状态码 204 ws-c: 返回重定向到 CAS 登录接口 Note over c, ss: 后面流程参考底下 Loop 循环 end else 不同时存在 ws-c: 返回重定向到 CAS 登录接口 loop 访问 CAS 登录页面 c-cs: 登录 alt 登录成功 cs-c: 返回带 ticket 的重定向，并在浏览器写入 pToken 的 cookie c-ws: 带有 ticket 的请求 ws--cs: 使用 ticket 置换 sToken alt 合法 ticket cs--ws: 返回 sToken ws-c: 返回用户请求内容，并在浏览器写入 sToken 的 cookie else 非法 ticket ws-c: 返回重定向到 CAS 登录接口 end else 登录失败 ss-c: 返回错误提示页面 end end end 百度 UUAP   用户访问接入 uuap 的下游系统 xx.baidu.com，例如 family.baidu.com。\n  下游系统后端 server 从 cookie 中获取 pToken 及 sToken，校验是否同时存在，不同时存在直接重定向用户到 uuap 登录接口认证。\n pToken：存在于 baidu.com（baidu-int.com）域名下，cookie 的名字为 UUAP_P_TOKEN，线下环境统一为 UUAP_P_TOKEN_OFFLINE sToken：存在于下游系统的域名下面、该值为 uuap 认证成功后签发的 ticket 参数、下游系统获取后将其存入您的域名下，有效期 30 天、该值通用名称为 UUAP_S_TOKEN\n   pToken 与 sToken\n 如果 pToken 与 sToken 同时存在，则将 pToken、sToken 及您的 appKey 作为参数，发送 POST 请求到 UUAP-SESSION 的 Session 登录校验校验用户是否正常登录，如果正常登录返回登录用户的基本信息，未正常登录则返回状态码 204，重定向用户到 uuap 登录接口认证 如果 pToken 与 sToken 不是同时存在，下游系统直接重定向用户到 uuap 登录接口认证。    如果 UUAP-SESSION 返回用户登录成功并且返回登录用户的基本信息，下游系统可允许用户访问受保护的内容。\n  如果 UUAP-SESSION 返回状态码 204，则按照 3-2 的步骤，下游系统直接通知前端跳转 UUAP-SSO 认证服务器认证。\n  下游系统携带 service 及 appKey 参数，访问 UUAP-SSO 的 uuap 登录接口接口请求用户认证。\n service：第 1 步中用户访问的下游系统的 url，请对该 url 进行 urlencode appKey：uuap 签发的下游系统唯一 id\n   UUAP-SSO 认证服务器认证通过会在 baidu 的根域名下植入 pToken 的 cookie，并且会在用户传递的 service 回调地址后面追加 ticket 参数通知用户跳转，下游系统 server 可获取该参数，调用 SToken 置换接口获取 SToken，将其以 cookie 的形式存入你们的域名下，该值就是 sToken。\n cookie 植入成功后要在之前访问 url 的基础上去除 ticket 参数让用户重新 302 访问一次，这样就能防止 server 看到访问 url 中存在 ticket 参数关键字陷入反复植入 sToken 的死循环，跳转后用户重新从第 1 步执行。    认证失败，跳转错误页面。\n   参考  mermaid  "});index.add({'id':2,'href':'/study-backend/docs/web-service/rpc/grpc/','title':"gRPC",'content':"gRPC "});index.add({'id':3,'href':'/study-backend/docs/auth/oauth/','title':"OAuth",'content':"OAuth 2.0 OAuth 2.0 协议参考 rfc6749\n1.0  参考  Choosing an SSO Strategy: SAML vs OAuth2  rfc6749 百度 UUAP OAuth "});index.add({'id':4,'href':'/study-backend/docs/web-service/rest/','title':"REST",'content':"REST Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services.\n"});index.add({'id':5,'href':'/study-backend/docs/web-service/standard/xml/','title':"XML",'content':"XML "});index.add({'id':6,'href':'/study-backend/docs/web-service/rpc/spring-cloud/','title':"Spring Cloud",'content':"Spring Cloud 国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言。\n"});index.add({'id':7,'href':'/study-backend/docs/web-service/rpc/dubbo/','title':"Dubbo",'content':"Dubbo 国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言\n"});index.add({'id':8,'href':'/study-backend/docs/web-service/standard/http/','title':"HTTP",'content':"HTTP 见：xxx\n"});index.add({'id':9,'href':'/study-backend/docs/auth/jwt/','title':"JWT",'content':"JWT JSON Web Tokens\n背景  JWT 原理 JWT 结构 JWT 由 Header, Payload, Signature 三部分组成\nconst token = base64urlEncoding(header) + '.' + base64urlEncoding(payload) + '.' + base64urlEncoding(signature)\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n  Header\n{ \u0026quot;alg\u0026quot; : \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot; : \u0026quot;JWT\u0026quot; }   Payload\n{ \u0026quot;loggedInAs\u0026quot; : \u0026quot;admin\u0026quot;, \u0026quot;iat\u0026quot; : 1422779638 }   Signature\nHMAC-SHA256( base64urlEncoding(header) + '.' + base64urlEncoding(payload), secret )   Authorization: Bearer eyJhbGci...\u0026lt;snip\u0026gt;...yu5CSpyHI\n JWT 优缺点 优点  JWT 把数据存储在客户端，服务端不需要存储  缺点  JWT 的 Token 无法主动失效   JWT 适用场景  参考  阮一峰：JSON Web Token 入门教程  "});index.add({'id':10,'href':'/study-backend/docs/frame/web/laravel/','title':"Laravel",'content':"Laravel "});index.add({'id':11,'href':'/study-backend/docs/db/redis/','title':"Redis",'content':"Redis "});index.add({'id':12,'href':'/study-backend/docs/mq/redis/','title':"Redis",'content':"Redis Kafka 是 linkedin 开源的 MQ 系统，主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，0.8 开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。\n"});index.add({'id':13,'href':'/study-backend/docs/web-service/rpc/','title':"RPC",'content':"RPC "});index.add({'id':14,'href':'/study-backend/docs/web-service/','title':"Web Service",'content':"Web Service "});index.add({'id':15,'href':'/study-backend/docs/frame/web/','title':"Web 框架",'content':"Web 框架 "});index.add({'id':16,'href':'/study-backend/docs/db/','title':"数据库",'content':"数据库 "});index.add({'id':17,'href':'/study-backend/docs/web-service/rpc/thrift/','title':"Thrift",'content':"Thrift 最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。\n"});index.add({'id':18,'href':'/study-backend/docs/mq/activemq/','title':"ActiveMQ",'content':"ActiveMQ "});index.add({'id':19,'href':'/study-backend/docs/db/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':20,'href':'/study-backend/docs/mq/rocketmq/','title':"RocketMQ",'content':"RocketMQ "});index.add({'id':21,'href':'/study-backend/docs/web-service/soa/','title':"SOA",'content':"SOA "});index.add({'id':22,'href':'/study-backend/docs/web-service/standard/soap/','title':"SOAP",'content':"SOAP "});index.add({'id':23,'href':'/study-backend/docs/auth/sso/','title':"SSO",'content':"SSO (Single sign-on) "});index.add({'id':24,'href':'/study-backend/docs/web-service/rpc/tars/','title':"Tars",'content':"Tars - Total Application Framework 腾讯内部使用的 RPC 框架，于 2017 年对外开源。\n目前支持 C++, Java 和 NodeJs 三种语言。\n"});index.add({'id':25,'href':'/study-backend/docs/web-service/standard/wsdl/','title':"WSDL",'content':"WSDL "});index.add({'id':26,'href':'/study-backend/docs/mq/','title':"消息队列",'content':"消息队列 ZeroMQ 和 RabbitMQ/Kafka 不同，它只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。\nRabbitMQ 支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。Kafka 使用自己的协议。\nKafka 自身服务和消费者都需要依赖 Zookeeper。\nRabbitMQ 在有大量消息堆积的情况下性能会下降，Kafka 不会。毕竟 AMQP 设计的初衷不是用来持久化海量消息的，而 Kafka 一开始是用来处理海量日志的。\n参考  RabbitMQ, ZeroMQ, Kafka 是一个层级的东西吗？  "});index.add({'id':27,'href':'/study-backend/docs/web-service/rpc/motan/','title':"Motan",'content':"Motan 微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n"});index.add({'id':28,'href':'/study-backend/docs/mq/rabbitmq/','title':"RabbitMQ",'content':"RabbitMQ RabbitMQ 是一个 AMQP 实现，传统的 messaging queue 系统实现，基于 Erlang。老牌 MQ 产品了。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。\n"});index.add({'id':29,'href':'/study-backend/docs/web-service/standard/uudi/','title':"UUDI",'content':"UUDI "});index.add({'id':30,'href':'/study-backend/docs/mq/zeromq/','title':"ZeroMQ",'content':"ZeroMQ ZeroMQ 只是一个网络编程的 Pattern 库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之 socket 之上、MQ 之下。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。\n"});index.add({'id':31,'href':'/study-backend/docs/auth/','title':"认证与授权",'content':"认证与授权 "});index.add({'id':32,'href':'/study-backend/docs/mq/mqtt/','title':"MQTT",'content':"MQTT mqtt 各种 broker 如何选择？\nAgent 和 Broker 的差别是什么？\n 经纪人（Broker）：是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。  Broker 是一个独立主体，但没有自主决策能力，只负责订约过程。   代理人（Agent）：是行使被代理者的权力，完成相关的使命或者任务主体。  Agent 是一个独立主体，负责完成任务但不负责执行任务，Agent 具有一定的自主决策能力，如对服务请求的选择。   代理（Proxy）是指行为代理，不是一个主体。  Proxy 是完全的传递者，如请求和响应的转发，操作控制的传递。    "});index.add({'id':33,'href':'/study-backend/docs/auth/sso/saml/','title':"SAML",'content':"SAML 1.0 2.0 参考  How SAML Authentication Works  "});index.add({'id':34,'href':'/study-backend/docs/frame/','title':"框架",'content':"后端框架 "});index.add({'id':35,'href':'/study-backend/docs/web-service/standard/','title':"相关标准",'content':"相关标准 "});index.add({'id':36,'href':'/study-backend/categories/','title':"Categories",'content':""});index.add({'id':37,'href':'/study-backend/docs/','title':"Docs",'content':""});index.add({'id':38,'href':'/study-backend/tags/','title':"Tags",'content':""});index.add({'id':39,'href':'/study-backend/','title':"首页",'content':""});})();